<!-- RUN WITH ALT + B 
                                      
-->>
<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Hexagon Wars: Battle w/ the Elements</title>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>

<body>
    <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP
    <script>
        var canvas = document.getElementById("renderCanvas"); // Get the canvas element 
        var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
        function HexesToCord(a, b) {
            //a is up direction, y
            //b is side direction, +y, +x
            //c is side direction, -y, +x
            //1 Hexagon = 2.54 "units" inside this game
            //[d,e] is x, y
            var d = 0
            var e = 0
            d += 2.54 * (0.86602540378 * (b))
            e += 2.54 * (a + 0.5 * (b))
            return [d, e]
        }

        function intersect(a, b, map, type) {
            isit = false
            for (var q = -1; q < 2; q++) {
                for (var r = -1; r < 2; r++) {
                    if ((q != 1 && r != -1) || (q != -1 && r != 1)) {
                        if (map[50 + a + q][shift + b + r] == 1) {
                            isit = true
                        }
                    }
                }
            }
            if (type == 2) {
                if (map[50 + a + 1][shift + b + 1] == 1) {
                    isit = true
                }
            }
            if (type == 3) {
                if (map[50 + a + 1][shift + b + 1] == 1 ||
                    map[50 + a + 1][shift + b - 2] == 1 ||
                    map[50 + a - 1][shift + b + 2] == 1 ||
                    map[50 + a - 2][shift + b + 1] == 1 ||
                    map[50 + a - 1][shift + b - 1] == 1 ||
                    map[50 + a + 2][shift + b - 1] == 1) {
                    isit = true
                }
            }
            return isit
        }

        function translation(i, g, mapVector) {
            dir = [0, 0]
            for (var k = 0; k < 4; k++) {
                try { throw k }
                catch (j) {
                    if (j != i) {
                        var tdir = [scene.getMeshByID("Exc" + i).hex[0] - scene.getMeshByID("Exc" + j).hex[0], scene.getMeshByID("Exc" + i).hex[1] - scene.getMeshByID("Exc" + j).hex[1]]
                        var dist = (tdir[0] * tdir[0] + tdir[1] * tdir[1])
                        dir[0] += tdir[0] * (1 / dist)
                        dir[1] += tdir[1] * (1 / dist)
                    }
                }
            }
            var pox = 0
            var poy = 0
            if (dir[0] != 0) {
                pox = Math.round(dir[0] / Math.sqrt(dir[0] * dir[0]))
            }
            if (dir[1] != 0) {
                poy = Math.round(dir[1] / Math.sqrt(dir[1] * dir[1]))
            }
            var t = Math.random
            var mp = mapVector
            if (t < 0.2) { mp[0] = 0 }
            else if (t < 0.4) { mp[1] = 0 }
            else if (t < 0.6) { mp = [0, 0] }
            else {
                mp[0] = Math.round(mp[0] / 300)
                mp[1] = Math.round(mp[1] / 300)
            }

            var r = Math.random
            if (r < 0.16) {
                if ([pox, poy] == [0, 1]) { [pox, poy] = [g + mp[0], 0 + mp[1]] }
                if ([pox, poy] == [1, 0]) { [pox, poy] = [0 + mp[0], g + mp[1]] }
                if ([pox, poy] == [-1, 1]) { [pox, poy] = [0 + mp[0], g + mp[1]] }
                if ([pox, poy] == [1, -1]) { [pox, poy] = [0 + mp[0], -g + mp[1]] }
                if ([pox, poy] == [0, -1]) { [pox, poy] = [-g + mp[0], 0 + mp[1]] }
                if ([pox, poy] == [-1, 0]) { [pox, poy] = [-g + mp[0], g + mp[1]] }
            } else if (r < 0.32) {
                if ([pox, poy] == [0, 1]) { [pox, poy] = [-g + mp[0], g + mp[1]] }
                if ([pox, poy] == [1, 0]) { [pox, poy] = [g + mp[0], -g + mp[1]] }
                if ([pox, poy] == [-1, 1]) { [pox, poy] = [-g + mp[0], 0 + mp[1]] }
                if ([pox, poy] == [1, -1]) { [pox, poy] = [g + mp[0], 0 + mp[1]] }
                if ([pox, poy] == [0, -1]) { [pox, poy] = [g + mp[0], -g + mp[1]] }
                if ([pox, poy] == [-1, 0]) { [pox, poy] = [0 + mp[0], -g + mp[1]] }
            } else if (r < 0.48) {
                if ([pox, poy] == [0, 1]) { [pox, poy] = [g + mp[0], -g + mp[1]] }
                if ([pox, poy] == [1, 0]) { [pox, poy] = [0 + mp[0], -g + mp[1]] }
                if ([pox, poy] == [-1, 1]) { [pox, poy] = [0 + mp[0], -g + mp[1]] }
                if ([pox, poy] == [1, -1]) { [pox, poy] = [-g + mp[0], 0 + mp[1]] }
                if ([pox, poy] == [0, -1]) { [pox, poy] = [0 + mp[0], g + mp[1]] }
                if ([pox, poy] == [-1, 0]) { [pox, poy] = [0 + mp[0], g + mp[1]] }
            } else if (r < 0.64) {
                if ([pox, poy] == [0, 1]) { [pox, poy] = [-g + mp[0], 0 + mp[1]] }
                if ([pox, poy] == [1, 0]) { [pox, poy] = [-g + mp[0], g + mp[1]] }
                if ([pox, poy] == [-1, 1]) { [pox, poy] = [g + mp[0], 0 + mp[1]] }
                if ([pox, poy] == [1, -1]) { [pox, poy] = [0 + mp[0], g + mp[1]] }
                if ([pox, poy] == [0, -1]) { [pox, poy] = [-g + mp[0], g + mp[1]] }
                if ([pox, poy] == [-1, 0]) { [pox, poy] = [g + mp[0], -g + mp[1]] }
            } else {
                pox = pox * (g + mp[0])
                poy = poy * (g + mp[1])
            }
            return [pox, poy]
        }

        var value = 0; // by default
        var map = [...Array(100)].map(e => Array(100).fill(value));
        //y, x instead of x, y. remember that for map
        var disk = []
        var diskNum = 0
        var resetted = false
        var mapVector = [0, 0]
        const shift = 50

        const ExcMove = 2
        const SoldierMove = 3
        const ArcherMove = 1
        const TechieMove = 4

        var createScene = function () {
            var scene = new BABYLON.Scene(engine);

            var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), scene);
            camera.setPosition(new BABYLON.Vector3(0, 20, 50));
            camera.upperBetaLimit = (Math.PI / 2) * 0.9;
            camera.lowerRadiusLimit = 10;
            camera.upperRadiusLimit = 100;
            camera.attachControl(canvas, true);

            var light = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, 20, 50), scene);
            scene.clearColor = new BABYLON.Color3(0.5, 0.5, 0.8);
            const nummap = 16
            const Anum = 10
            const Bnum = 4
            const Cnum = 2

            var numqmap = 0
            var Aqnum = 0
            var Bqnum = 0
            var Cqnum = 0
            var loading = false

            const Players = 4
            var Pnum = 0
            var countNums = 0
            //load numbers
            if (loading == false) {
                for (var i = 0; i < 10; i++) {
                    try { throw i }
                    catch (counted) {
                        BABYLON.SceneLoader.ImportMesh(
                            null,
                            "https://raw.githubusercontent.com/Rizzist/HexagonWar/master/numbers/",
                            counted + ".obj",
                            scene,
                            function (num) {
                                var mesh = num[0];
                                mesh.isVisible = false;

                                var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
                                myMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0)
                                mesh.material = myMaterial

                                var newInstance = mesh.createInstance("" + counted);

                                newInstance.offsetX = -1.5
                                newInstance.offsetY = -2
                                newInstance.offsetZ = 5

                                if (counted == 0) { newInstance.offsetX -= 999 }
                                if (counted == 2) { newInstance.offsetX -= 1.65 }
                                if (counted == 3) { newInstance.offsetX -= 3.8 }
                                if (counted == 4) { newInstance.offsetX -= 5.4 }
                                if (counted == 5) { newInstance.offsetX -= 999 }
                                if (counted == 6) { newInstance.offsetX -= 999 }
                                if (counted == 7) { newInstance.offsetX -= 999 }
                                if (counted == 8) { newInstance.offsetX -= 999 }
                                if (counted == 9) { newInstance.offsetX -= 999 }

                                newInstance.hex = [0, 0]
                                newInstance.isVisible = false
                                newInstance.position.x = newInstance.offsetX
                                newInstance.position.z = newInstance.offsetY
                                newInstance.position.y = newInstance.offsetZ
                                newInstance.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);
                                newInstance.setPivotMatrix(BABYLON.Matrix.Translation(newInstance.offsetX, -0.07, 0), true)
                                newInstance.rotation.x = 0
                                newInstance.rotation.y = 0
                                newInstance.rotation.z = 0
                                newInstance.rotval = -Math.PI / 2
                                newInstance.picked = false
                                newInstance.isDisk = false
                            });
                    }
                }
            };




            while (numqmap < nummap) {
                q = Math.random()
                if (q < 0.33 && Aqnum < Anum) {
                    BABYLON.SceneLoader.ImportMesh(
                        null,
                        "https://raw.githubusercontent.com/Rizzist/HexagonWar/master/",
                        "A.obj",
                        scene,
                        function (A) {
                            var mesh = A[0];
                            mesh.isVisible = false;
                            var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
                            myMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7)
                            mesh.material = myMaterial
                            var newInstance = mesh.createInstance("A" + Anum);
                            [a, b] = [0, 0]
                            while (intersect(a, b, map, 1) == true) {
                                d = Math.random()
                                if (d <= 0.25) {
                                    a += 1
                                } else if (d < 0.5) {
                                    a -= 1
                                } else if (d <= 0.75 + (Math.random() - 0.5) / 10) {
                                    b += 1
                                } else {
                                    b -= 1
                                }
                            }
                            [x, y] = HexesToCord(a, b)

                            dOffsetZ = 0.7
                            dOffsetX = -0.01
                            dOffsetY = -2.05

                            newInstance.position.x = x
                            newInstance.position.z = y
                            newInstance.rotate(BABYLON.Axis.X, -Math.PI / 2, BABYLON.Space.WORLD);
                            for (var q = -1; q < 2; q++) {
                                for (var r = -1; r < 2; r++) {
                                    if (((q != 1 && r != -1) || (q != -1 && r != 1)) && map[50 + a + q][shift + b + r] == 0) {
                                        map[50 + a + q][shift + b + r] = 1
                                        mapVector[0] += Math.sqrt((a + q) * (a + q))
                                        mapVector[1] += Math.sqrt((b + r) * (b + r))
                                    }
                                }
                            }
                        });
                    Aqnum += 1
                    numqmap += 1
                } else if (q < 0.66 && Bqnum < Bnum) {
                    BABYLON.SceneLoader.ImportMesh(
                        null,
                        "https://raw.githubusercontent.com/Rizzist/HexagonWar/master/",
                        "B.obj",
                        scene,
                        function (B) {
                            var mesh = B[0];
                            mesh.isVisible = false;
                            var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
                            myMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7)
                            mesh.material = myMaterial
                            var newInstance = mesh.createInstance("B" + Bnum);
                            [a, b] = [0, 0]
                            d = 0
                            while (intersect(a, b, map, 2) == true) {
                                d = Math.random()
                                if (d <= 0.25) {
                                    a += 1
                                } else if (d < 0.5) {
                                    a -= 1
                                } else if (d <= 0.75 + (Math.random() - 0.5) / 10) {
                                    b += 1
                                } else {
                                    b -= 1
                                }
                            }
                            [x, y] = HexesToCord(a, b)
                            offsetX = -2.54 * 3.935
                            offsetY = 2.54 * -3.935
                            offsetZ = 2.54 * 0.1
                            newInstance.position.x = x + offsetX
                            newInstance.position.z = y + offsetY
                            newInstance.position.y = offsetZ
                            newInstance.rotate(BABYLON.Axis.X, -Math.PI / 2, BABYLON.Space.WORLD);
                            for (var q = -1; q < 2; q++) {
                                for (var r = -1; r < 2; r++) {
                                    if (((q != 1 && r != -1) || (q != -1 && r != 1)) && map[50 + a + q][shift + b + r] == 0) {
                                        map[50 + a + q][shift + b + r] = 1
                                        mapVector[0] += Math.sqrt((a + q) * (a + q))
                                        mapVector[1] += Math.sqrt((b + r) * (b + r))
                                    }
                                }
                            }

                            if (map[50 + a + 1][shift + b + 1] == 0) {
                                map[50 + a + 1][shift + b + 1] = 1
                                mapVector[0] += Math.sqrt((a + 1) * (a + 1))
                                mapVector[1] += Math.sqrt((b + 1) * (b + 1))
                            }
                        });
                    Bqnum += 1
                    numqmap += 1
                } else if (Cqnum < Cnum) {
                    BABYLON.SceneLoader.ImportMesh(
                        null,
                        "https://raw.githubusercontent.com/Rizzist/HexagonWar/master/",
                        "C.obj",
                        scene,
                        function (C) {
                            var mesh = C[0];
                            mesh.isVisible = false;

                            var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
                            myMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7)
                            mesh.material = myMaterial

                            var newInstance = mesh.createInstance("C" + Cnum);
                            [a, b] = [0, 0]
                            d = 0
                            while (intersect(a, b, map, 3) == true) {
                                d = Math.random()
                                if (d <= 0.25) {
                                    a += 1
                                } else if (d < 0.5) {
                                    a -= 1
                                } else if (d <= 0.75 + (Math.random() - 0.5) / 10) {
                                    b += 1
                                } else {
                                    b -= 1
                                }
                            }
                            [x, y] = HexesToCord(a, b)
                            offsetX = -2.54 * 3.935
                            offsetY = 2.54 * 0
                            offsetZ = 2.54 * 0
                            newInstance.position.x = x + offsetX
                            newInstance.position.z = y + offsetY
                            newInstance.position.y = offsetZ
                            newInstance.rotate(BABYLON.Axis.X, -Math.PI / 2, BABYLON.Space.WORLD);
                            for (var q = -1; q < 2; q++) {
                                for (var r = -1; r < 2; r++) {
                                    if (((q != 1 && r != -1) || (q != -1 && r != 1)) && map[50 + a + q][shift + b + r] == 0) {
                                        map[50 + a + q][shift + b + r] = 1
                                        mapVector[0] += Math.sqrt((a + q) * (a + q))
                                        mapVector[1] += Math.sqrt((b + r) * (b + r))
                                    }
                                }
                            }
                            if (map[50 + a + 1][shift + b + 1] == 0) {
                                map[50 + a + 1][shift + b + 1] = 1
                                mapVector[0] += Math.sqrt((a + 1) * (a + 1))
                                mapVector[1] += Math.sqrt((b + 1) * (b + 1))
                            }
                            if (map[50 + a + 1][shift + b - 2] == 0) {
                                map[50 + a + 1][shift + b - 2] = 1
                                mapVector[0] += Math.sqrt((a + 1) * (a + 1))
                                mapVector[1] += Math.sqrt((b - 1) * (b - 1))
                            }
                            if (map[50 + a - 1][shift + b + 2] == 0) {
                                map[50 + a - 1][shift + b + 2] = 1
                                mapVector[0] += Math.sqrt((a - 1) * (a - 1))
                                mapVector[1] += Math.sqrt((b + 2) * (b + 2))
                            }
                            if (map[50 + a - 2][shift + b + 1] == 0) {
                                map[50 + a - 2][shift + b + 1] = 1
                                mapVector[0] += Math.sqrt((a - 2) * (a - 2))
                                mapVector[1] += Math.sqrt((b + 1) * (b + 1))
                            }
                            if (map[50 + a + 2][shift + b - 1] == 0) {
                                map[50 + a + 2][shift + b - 1] = 1
                                mapVector[0] += Math.sqrt((a + 2) * (a + 2))
                                mapVector[1] += Math.sqrt((b - 1) * (b - 1))
                            }
                            if (map[50 + a - 1][shift + b - 1] == 0) {
                                map[50 + a - 1][shift + b - 1] = 1
                                mapVector[0] += Math.sqrt((a - 1) * (a - 1))
                                mapVector[1] += Math.sqrt((b - 1) * (b - 1))
                            }
                        });
                    Cqnum += 1
                    numqmap += 1
                }
            }



            //Players, not map (while & forloop dont work, copy pase code 4 times)
            //Excavators
            if (loading == false) {
                for (var i = -5; i < 9; i++) {
                    try { throw i }
                    catch (j) {
                        BABYLON.SceneLoader.ImportMesh(
                            null,
                            "https://raw.githubusercontent.com/Rizzist/HexagonWar/master/",
                            "Excavator.obj",
                            scene,
                            function (Exc) {
                                var mesh = Exc[0];
                                mesh.isVisible = false;
                                var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
                                myMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1)
                                if (j == 0) { myMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0) }
                                if (j == 1) { myMaterial.diffuseColor = new BABYLON.Color3(1, 1, 0) }
                                if (j == 2) { myMaterial.diffuseColor = new BABYLON.Color3(0, 0, 1) }
                                if (j == 3) { myMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0) }


                                mesh.material = myMaterial

                                var newInstance = mesh.createInstance("Exc" + j);
                                [x, y] = HexesToCord(999, 999)
                                newInstance.hex = [999, 999]
                                if (j == 0) {
                                    [x, y] = HexesToCord(0, 0)
                                    newInstance.hex = [0, 0]
                                    map[50][shift] = 2
                                }
                                if (j == 1) {
                                    [x, y] = HexesToCord(1, 0)
                                    newInstance.hex = [1, 0]
                                    map[51][shift] = 2
                                }
                                if (j == 2) {
                                    [x, y] = HexesToCord(0, -1)
                                    newInstance.hex = [0, -1]
                                    map[50][shift - 1] = 2
                                }
                                if (j == 3) {
                                    [x, y] = HexesToCord(0, 1)
                                    newInstance.hex = [0, 1]
                                    map[50][shift + 1] = 2
                                }
                                newInstance.offsetX = -2.54 * 7.3
                                newInstance.offsetY = -2.54 * 2.58
                                newInstance.offsetZ = 2.54 * 0.278
                                newInstance.move = ExcMove

                                newInstance.position.x = x + newInstance.offsetX
                                newInstance.position.z = y + newInstance.offsetY
                                newInstance.position.y = newInstance.offsetZ
                                newInstance.rotate(BABYLON.Axis.X, -Math.PI / 2, BABYLON.Space.WORLD);
                                newInstance.picked = false
                                newInstance.isDisk = false
                            });
                    }
                }
            }


            scene.onPointerDown = function (evt, pickResult) {

                if (resetted == false) {
                    var hexes = []
                    var upper = 0
                    for (var i = 0; i < 100; i++) {
                        for (var j = 0; j < 100; j++) {
                            if (map[i][j] != 0) {
                                hexes.push([i, j])
                                upper += 1
                            }
                        }
                    }

                    for (var i = 0; i < upper; i++) {
                        var [u, v] = HexesToCord(hexes[i][0] - 50, hexes[i][1] - shift)
                        disk[diskNum] = BABYLON.MeshBuilder.CreateDisc('' + (hexes[i][0] - 50) + '00' + (hexes[i][1] - shift), { radius: 1, arc: 1, tessellation: 6, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
                        var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
                        myMaterial.diffuseColor = new BABYLON.Color3(0.9, 1, 0.8)
                        scene.getMeshByID('' + (hexes[i][0] - 50) + '00' + (hexes[i][1] - shift)).material = myMaterial
                        scene.getMeshByID('' + (hexes[i][0] - 50) + '00' + (hexes[i][1] - shift)).rotate(BABYLON.Axis.X, -Math.PI / 2, BABYLON.Space.WORLD)
                        scene.getMeshByID('' + (hexes[i][0] - 50) + '00' + (hexes[i][1] - shift)).position.y = dOffsetZ
                        scene.getMeshByID('' + (hexes[i][0] - 50) + '00' + (hexes[i][1] - shift)).position.x = u + dOffsetX
                        scene.getMeshByID('' + (hexes[i][0] - 50) + '00' + (hexes[i][1] - shift)).position.z = v + dOffsetY
                        scene.getMeshByID('' + (hexes[i][0] - 50) + '00' + (hexes[i][1] - shift)).isVisible = false
                        scene.getMeshByID('' + (hexes[i][0] - 50) + '00' + (hexes[i][1] - shift)).isDisk = true
                        scene.getMeshByID('' + (hexes[i][0] - 50) + '00' + (hexes[i][1] - shift)).hex = [hexes[i][0] - 50, hexes[i][1] - shift]
                        diskNum += 1
                    }
                    for (var f = 0; f < 50; f++) {
                        for (var w = 0; w < 5; w++) {
                            try { throw w }
                            catch (m) {
                                for (var i = 0; i < 4; i++) {
                                    try { throw i }
                                    catch (j) {
                                        var g = m
                                        gett = translation(j, 5 - g, mapVector)
                                        var [a, b] = scene.getMeshByID("Exc" + j).hex
                                        if (((50 + a + gett[0]) < 100 && (shift + b + gett[1]) < 100)
                                            && ((50 + a + gett[0]) > 0 && (shift + b + gett[1]) > 0)
                                            && map[50 + a + gett[0]][shift + b + gett[1]] != 0) {
                                            map[50 + a][shift + b] = 1
                                            map[50 + a + gett[0]][shift + b + gett[1]] = 2
                                            var [x, y] = HexesToCord(a + gett[0], b + gett[1])
                                            scene.getMeshByID("Exc" + j).hex = [a + gett[0], b + gett[1]]
                                            scene.getMeshByID("Exc" + j).position.x = x + scene.getMeshByID("Exc" + j).offsetX
                                            scene.getMeshByID("Exc" + j).position.z = y + scene.getMeshByID("Exc" + j).offsetY
                                        }
                                    }
                                }
                            }
                        }
                    }

                    BABYLON.SceneLoader.ImportMesh(
                        null,
                        "https://raw.githubusercontent.com/Rizzist/HexagonWar/master/",
                        "Soldier.obj",
                        scene,
                        function (Soldier) {
                            var mesh = Soldier[0];
                            mesh.isVisible = false;
                            var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
                            myMaterial.diffuseColor = new BABYLON.Color3(1, 0.65, 0)

                            mesh.material = myMaterial
                            var j = 0
                            var newInstance = mesh.createInstance("Soldier" + j);
                            [x, y] = HexesToCord(999, 999)
                            newInstance.hex = [999, 999]
                            if (j == 0) {
                                [x, y] = HexesToCord(0, 0)
                                newInstance.hex = [0, 0]
                                map[50][shift] = 3
                            }
                            if (j == 1) {
                                [x, y] = HexesToCord(1, 0)
                                newInstance.hex = [1, 0]
                                map[51][shift] = 3
                            }
                            if (j == 2) {
                                [x, y] = HexesToCord(0, -1)
                                newInstance.hex = [0, -1]
                                map[50][shift - 1] = 3
                            }
                            if (j == 3) {
                                [x, y] = HexesToCord(0, 1)
                                newInstance.hex = [0, 1]
                                map[50][shift + 1] = 3
                            }
                            newInstance.offsetX = -2.54 * 8
                            newInstance.offsetY = -2.54 * 0.85
                            newInstance.offsetZ = 2.54 * 0.278
                            newInstance.move = SoldierMove

                            newInstance.position.x = x + newInstance.offsetX
                            newInstance.position.z = y + newInstance.offsetY
                            newInstance.position.y = newInstance.offsetZ
                            newInstance.rotate(BABYLON.Axis.X, -Math.PI / 2, BABYLON.Space.WORLD);
                            newInstance.picked = false
                            newInstance.isDisk = false

                            BABYLON.SceneLoader.ImportMesh(
                                null,
                                "https://raw.githubusercontent.com/Rizzist/HexagonWar/master/",
                                "Plate.obj",
                                scene,
                                function (Plate) {
                                    var mesh = Plate[0];
                                    mesh.isVisible = false;
                                    var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
                                    myMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0)

                                    mesh.material = myMaterial
                                    var j = 0
                                    var newInstance2 = mesh.createInstance("Plate" + j);
                                    [x, y] = HexesToCord(999, 999)
                                    newInstance2.hex = [999, 999]
                                    if (j == 0) {
                                        [x, y] = HexesToCord(0, 0)
                                        newInstance2.hex = [0, 0]
                                    }
                                    if (j == 1) {
                                        [x, y] = HexesToCord(1, 0)
                                        newInstance2.hex = [1, 0]
                                    }
                                    if (j == 2) {
                                        [x, y] = HexesToCord(0, -1)
                                        newInstance2.hex = [0, -1]
                                    }
                                    if (j == 3) {
                                        [x, y] = HexesToCord(0, 1)
                                        newInstance2.hex = [0, 1]
                                    }
                                    newInstance2.offsetX = -2.54 * 8
                                    newInstance2.offsetY = -2.54 * 0.85
                                    newInstance2.offsetZ = 2.54 * 0.278
                                    newInstance2.move = 0

                                    newInstance2.position.x = x + newInstance2.offsetX
                                    newInstance2.position.z = y + newInstance2.offsetY
                                    newInstance2.position.y = newInstance2.offsetZ
                                    newInstance2.rotate(BABYLON.Axis.X, -Math.PI / 2, BABYLON.Space.WORLD);
                                    newInstance2.picked = false
                                    newInstance2.isDisk = false
                                });
                        });


                    BABYLON.SceneLoader.ImportMesh(
                        null,
                        "https://raw.githubusercontent.com/Rizzist/HexagonWar/master/",
                        "Archer.obj",
                        scene,
                        function (Archer) {
                            var mesh = Archer[0];
                            mesh.isVisible = false;
                            var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
                            myMaterial.diffuseColor = new BABYLON.Color3(1, 0.65, 0)

                            mesh.material = myMaterial
                            var j = 0
                            var newInstance = mesh.createInstance("Archer" + j);
                            [x, y] = HexesToCord(999, 999)
                            newInstance.hex = [999, 999]
                            if (j == 0) {
                                [x, y] = HexesToCord(1, -1)
                                newInstance.hex = [-1, 1]
                                map[50][shift] = 4
                            }
                            if (j == 1) {
                                [x, y] = HexesToCord(1, 0)
                                newInstance.hex = [1, 0]
                                map[51][shift] = 4
                            }
                            if (j == 2) {
                                [x, y] = HexesToCord(0, -1)
                                newInstance.hex = [0, -1]
                                map[50][shift - 1] = 4
                            }
                            if (j == 3) {
                                [x, y] = HexesToCord(0, 1)
                                newInstance.hex = [0, 1]
                                map[50][shift + 1] = 4
                            }
                            newInstance.offsetX = -2.54 * 9.79
                            newInstance.offsetY = -2.54 * 0.85
                            newInstance.offsetZ = 2.54 * 0.278
                            newInstance.move = SoldierMove

                            newInstance.position.x = x + newInstance.offsetX
                            newInstance.position.z = y + newInstance.offsetY
                            newInstance.position.y = newInstance.offsetZ
                            newInstance.rotate(BABYLON.Axis.X, -Math.PI / 2, BABYLON.Space.WORLD);
                            newInstance.picked = false
                            newInstance.isDisk = false
                        });


                    resetted = true
                }



                //check if any dudes picked
                var checker = false
                for (var o = 0; o < 4; o++) {
                    try { throw o }
                    catch (u) {
                        if (scene.getMeshByID('Exc' + u).picked == true) {
                            checker = true
                        }
                    }
                }
                if (checker == false) {
                    for (var l = 0; l < 10; l++) {
                        try { throw l }
                        catch (p) {
                            scene.getMeshByID('' + p).isVisible = false
                        }
                    }
                }


                // if the click hits the ground object, we change the impact position
                if (pickResult.hit) {


                    for (var j = 0; j < 4; j++) {
                        try { throw j }
                        catch (i) {
                            if (pickResult.pickedMesh.id == ("Exc" + i) && scene.getMeshByID('Exc' + (i - 1)).picked == false
                                && scene.getMeshByID('Exc' + (i - 2)).picked == false && scene.getMeshByID('Exc' + (i - 3)).picked == false
                                && scene.getMeshByID('Exc' + (i + 1)).picked == false
                                && scene.getMeshByID('Exc' + (i + 2)).picked == false && scene.getMeshByID('Exc' + (i + 3)).picked == false) {
                                if (pickResult.pickedMesh.picked == false) {
                                    scene.getMeshByID('Exc' + i).material.diffuseColor = new BABYLON.Color3(0.8, 0.4, 0.9)
                                    scene.getMeshByID('Exc' + i).picked = true
                                    if (scene.getMeshByID('Exc' + i).move > 0) {
                                        var [u, v] = scene.getMeshByID('Exc' + i).hex
                                        for (var q = -1; q < 2; q++) {
                                            for (var r = -1; r < 2; r++) {
                                                if (((q != 1 && r != -1) || (q != -1 && r != 1)) && map[50 + u + q][shift + v + r] == 1) {
                                                    scene.getMeshByID('' + (u + q) + '00' + (v + r)).material.diffuseColor = new BABYLON.Color3(0.9, 1, 0.8)
                                                    scene.getMeshByID('' + (u + q) + '00' + (v + r)).isVisible = true
                                                }
                                            }
                                        }
                                    }
                                    [x, y] = HexesToCord(scene.getMeshByID('Exc' + i).hex[0], scene.getMeshByID('Exc' + i).hex[1])
                                    scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).isVisible = true
                                    scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).hex = scene.getMeshByID('Exc' + i).hex
                                    scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).position.x = x + scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).offsetX
                                    scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).position.z = y + scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).offsetY
                                } else {
                                    var materials = new BABYLON.Color3(1, 0, 0)
                                    if (i == 1) { materials = new BABYLON.Color3(1, 1, 0) }
                                    if (i == 2) { materials = new BABYLON.Color3(0, 0, 1) }
                                    if (i == 3) { materials = new BABYLON.Color3(0, 1, 0) }
                                    scene.getMeshByID('Exc' + i).material.diffuseColor = materials
                                    scene.getMeshByID('Exc' + i).picked = false
                                    var [u, v] = scene.getMeshByID('Exc' + i).hex
                                    for (var q = -1; q < 2; q++) {
                                        for (var r = -1; r < 2; r++) {
                                            if (((q != 1 && r != -1) || (q != -1 && r != 1)) && map[50 + u + q][shift + v + r] == 1) {
                                                scene.getMeshByID('' + (u + q) + '00' + (v + r)).material.diffuseColor = new BABYLON.Color3(0.9, 1, 0.8)
                                                scene.getMeshByID('' + (u + q) + '00' + (v + r)).isVisible = false
                                            }
                                        }
                                    }
                                    for (var l = 0; l < 10; l++) {
                                        try { throw l }
                                        catch (p) {
                                            scene.getMeshByID('' + p).isVisible = false
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (pickResult.pickedMesh.isDisk == true) {
                        for (i = 0; i < 4; i++) {
                            if (scene.getMeshByID('Exc' + i).picked == true && scene.getMeshByID('Exc' + i).move > 0) {
                                var [u, v] = scene.getMeshByID('Exc' + i).hex
                                for (var q = -1; q < 2; q++) {
                                    for (var r = -1; r < 2; r++) {
                                        if (((q != 1 && r != -1) || (q != -1 && r != 1)) && map[50 + u + q][shift + v + r] == 1) {
                                            scene.getMeshByID('' + (u + q) + '00' + (v + r)).material.diffuseColor = new BABYLON.Color3(0.9, 1, 0.8)
                                            scene.getMeshByID('' + (u + q) + '00' + (v + r)).isVisible = false
                                        }
                                    }
                                }
                                map[u + 50][v + shift] = 1
                                scene.getMeshByID('Exc' + i).move -= 1
                                scene.getMeshByID('Exc' + i).hex = pickResult.pickedMesh.hex
                                var [m, n] = HexesToCord(scene.getMeshByID('Exc' + i).hex[0], scene.getMeshByID('Exc' + i).hex[1])
                                scene.getMeshByID('Exc' + i).position.x = m + scene.getMeshByID('Exc' + i).offsetX
                                scene.getMeshByID('Exc' + i).position.z = n + scene.getMeshByID('Exc' + i).offsetY
                                scene.getMeshByID('Exc' + i).position.y = 0 + scene.getMeshByID('Exc' + i).offsetZ

                                for (var l = 0; l < 10; l++) {
                                    try { throw l }
                                    catch (p) {
                                        scene.getMeshByID('' + p).isVisible = false
                                    }
                                }

                                [x, y] = HexesToCord(scene.getMeshByID('Exc' + i).hex[0], scene.getMeshByID('Exc' + i).hex[1])
                                scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).isVisible = true
                                scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).hex = scene.getMeshByID('Exc' + i).hex
                                scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).position.x = x + scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).offsetX
                                scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).position.z = y + scene.getMeshByID('' + scene.getMeshByID('Exc' + i).move).offsetY
                                var [u, v] = scene.getMeshByID('Exc' + i).hex
                                map[u + 50][v + shift] = 2

                                if (scene.getMeshByID('Exc' + i).move > 0) {
                                    for (var q = -1; q < 2; q++) {
                                        for (var r = -1; r < 2; r++) {
                                            if (((q != 1 && r != -1) || (q != -1 && r != 1)) && map[50 + u + q][shift + v + r] == 1) {
                                                scene.getMeshByID('' + (u + q) + '00' + (v + r)).material.diffuseColor = new BABYLON.Color3(0.9, 1, 0.8)
                                                scene.getMeshByID('' + (u + q) + '00' + (v + r)).isVisible = true
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
            scene.registerBeforeRender(function () {
                if (resetted == true) {
                    for (var l = 0; l < 10; l++) {
                        try { throw l }
                        catch (p) {
                            var angle = camera.alpha - scene.getMeshByID('' + p).rotval
                            scene.getMeshByID('' + p).rotval += angle / 12
                            scene.getMeshByID('' + p).rotate(BABYLON.Axis.Z, angle / 12)
                        }
                    }
                }
                light.position = camera.position;
            });
            return scene;
        };
        var scene = createScene();

        engine.runRenderLoop(function () {
            scene.render();
        });
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>

</html>